### **2019/09/09 - 2019/09/15** :watch:

- es6的继承是如何实现的？

  <details>
  <summary>点击</summary>

  简单的说：

  ```js
  subClass.prototype.__proto__ = superClass.prototype

  subClass.__proto__ = superClass
  ```
  那为什么这样一倒腾，它就实现了继承了呢?

  首先 `subClass.prototype.__proto__ = superClass.prototype` 保证了 `c instanceof Parent` 是 `true` , Child 的实例可以访问到父类的属性，包括内部属性，以及原型属性。其次，`subClass.__proto__ = superClass`，保证了 `Child.height` 也能访问到，也就是静态方法。
  
  </details>


### **2019/09/02 - 2019/09/08** :watch:

- GIT 中 pull 与 fetch 的区别？


  <details>
  <summary>点击</summary>

  使用 git fetch 更新代码，本地的库中 master 的 commitID 不变，还是等于1。但是与 git 上面关联的那个 `orign/master` 的 commit ID 变成了 2。这时候我们本地相当于存储了两个代码的版本号，我们还要通过 merge 去合并这两个不同的代码版本，如果这两个版本都修改了同一处的代码，这时候 merge 就会出现冲突，然后我们解决冲突之后就生成了一个新的代码版本。

  这时候本地的代码版本可能就变成了commit ID=3，即生成了一个新的代码版本。

  git pull更新代码的话就比较简单暴力了,使用 git pull 的会将本地的代码更新至远程仓库里面最新的代码版本,看起来像 `git fetch + get merge`，但是根据 commit ID 来看的话，他们实际的实现原理是不一样的(commit id 覆盖了远程的)。

  ```
  不要用git pull，用git fetch和git merge代替它。

  git pull的问题是它把过程的细节都隐藏了起来，以至于你不用去了解git中各种类型分支的区别和使用方法。当然，多数时候这是没问题的，但一旦代码有问题，你很难找到出错的地方。看起来git pull的用法会使你吃惊，简单看一下git的使用文档应该就能说服你。

  将下载（fetch）和合并（merge）放到一个命令里的另外一个弊端是，你的本地工作目录在未经确认的情况下就会被远程分支更新。当然，除非你关闭所有的安全选项，否则git pull在你本地工作目录还不至于造成不可挽回的损失，但很多时候我们宁愿做的慢一些，也不愿意返工重来。

  ```

  </details>


- [详解 js 位运算？](../javascript/详解javascript位运算.md)

- 电商项目中的价格由前端计算还是后端计算，为什么？

  <details>
  <summary>点击</summary>

  如购物车的价格，由前端计算显示，能提高用户体验；
  
  订单实际价格应由后端进行计算，如果由前端进行计算，可能出现代码注入修改价格，或者是伪装用户身份提交极低的价格生成订单，或者是拦截请求修改请求的价格参数，这些都是很危险的。

  所以显示由前端进行计算，实际价格应由后端进行计算，这样会出现一个问题：如果前端计算不正确该怎么办？此时想到的办法就是在前端计算完价格后显示给用户，然后调用后台接口计算价格判断是否有误，再进行抉择。

  </details>

- html 如何设置不缓存？

- vue 实例化做了哪些事？

- var 与 let 的区别

  <details>
  <summary>点击</summary>

  1. 可以用 let 定义块级作用域变量
  2. let 没有变量提升与暂时性死区
  3. let 变量不能重复声明

  </details>

- 搜索二叉树的中序遍历排序

  <details>
  <summary>点击</summary>
    
  对于任意一个节点，先遍历他的左子树，再遍历本身，再遍历右子树，最后得到一个升序的数组

  ```js
  function Node(val) {
    this.left = null;
    this.right = null;
    this.value = val;
  }

  function generateBST(root, array) {
    var length = array.length;

    for (var i = 1; i < length; i++) {
      insertNode(root, array[i]);
    }
  }

  function insertNode(node, value) {
    if (value < node.value) {
      if (node.left === null) {
        node.left = new Node(value);
      } else {
        node = node.left;
        insertNode(node, value);
      }
    } else {
      if (node.right === null) {
        node.right = new Node(value);
      } else {
        node = node.right;
        insertNode(node, value);
      }
    }
  }

  var array = [2, 3, 4, 12, 3, 54, 6, 7, 1];
  var root = new Node(array[0]);

  generateBST(root, array);

  // 中序遍历
  function inorderSearch(root) {
    var array = [];

    _inorderSearch(root, array);
    return array;
  }

  function _inorderSearch(node, array) {
    if (!node) {
      return;
    }
    _inorderSearch(node.left, array);
    array.push(node.value);
    _inorderSearch(node.right, array);
  }
  console.log(root);
  console.log(inorderSearch(root));
  ```

  </details>
