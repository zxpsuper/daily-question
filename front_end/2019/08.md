### **2019/08/12 - 2019/08/18** :watch:

- [为什么 Javascript 要是单线程的?](../浏览器/为什么Javascript要是单线程的.md)

- [5.什么是关键渲染路径?如何优化?](../浏览器/为什么Javascript要是单线程的.md#5.什么是关键渲染路径?如何优化?)

### **2019/08/05 - 2019/08/11** :watch:

- [HTTP2 与 HTTP1.1 的区别？](../浏览器/HTTP2与HTTP1.1的区别.md)

- vm.\$set()实现原理是什么?

  <details>
  <summary>点击</summary>

  因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染,产生副作用。

  所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。new Vue 的实例是不会被复用的,因此不存在以上问题。

  ```js
  export function set(target: Array<any> | Object, key: any, val: any): any {
    // target 为数组
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      // 修改数组的长度, 避免索引>数组长度导致splice()执行有误
      target.length = Math.max(target.length, key); // 利用数组的splice变异方法触发响应式
      target.splice(key, 1, val);
      return val;
    }
    // target为对象, key在target或者target.prototype上 且必须不能在 Object.prototype 上,直接赋值
    if (key in target && !(key in Object.prototype)) {
      target[key] = val;
      return val;
    }
    // 以上都不成立, 即开始给target创建一个全新的属性
    // 获取Observer实例
    const ob = (target: any).__ob__; // target 本身就不是响应式数据, 直接赋值
    if (!ob) {
      target[key] = val;
      return val;
    }
    // 进行响应式处理
    defineReactive(ob.value, key, val);
    ob.dep.notify();
    return val;
  }
  ```

  1. 如果目标是数组,使用 vue 实现的变异方法 splice 实现响应式

  2. 如果目标是对象,判断属性存在,即为响应式,直接赋值

  3. 如果 target 本身就不是响应式,直接赋值

  4. 如果属性不是响应式,则调用 defineReactive 方法进行响应式处理

  </details>

- Vue 组件 data 为什么必须是函数 ?

  <details>
  <summary>点击</summary>

  因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染,产生副作用。

  所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。new Vue 的实例是不会被复用的,因此不存在以上问题。

  </details>

- vue 是如何对数组方法进行变异的 ?

  <details>
  <summary>点击</summary>

  简单来说,Vue 通过原型拦截的方式重写了数组的 7 个方法,首先获取到这个数组的 ob,也就是它的 Observer 对象,如果有新的值,就调用 observeArray 对新的值进行监听,然后手动调用 notify,通知 render watcher,执行 update

  </details>

- Vue 中的 key 到底有什么用？

  <details>
  <summary>点击</summary>

  key 是给每一个 vnode 的唯一 id,依靠 key,我们的 diff 操作可以更准确、更快速 (对于简单列表页渲染来说 diff 节点也更快,但会产生一些隐藏的副作用,比如可能不会产生过渡效果,或者在某些节点有绑定数据（表单）状态，会出现状态错位。)

  diff 算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的 key 与旧节点进行比对,从而找到相应旧节点.

  更准确 : 因为带 key 就不是就地复用了,在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确,如果不加 key,会导致之前节点的状态被保留下来,会产生一系列的 bug。

  更快速 : key 的唯一性可以被 Map 数据结构充分利用,相比于遍历查找的时间复杂度 O(n),Map 的时间复杂度仅仅为 O(1),源码如下:

  </details>

- [computed 和 watch 有什么区别及运用场景?](../vue/computed和watch有什么区别及运用场景.md)
- [computed 的实现原理](../vue/computed的实现原理.md)

### **2019/07/29 - 2019/08/04** :watch:

- [Vue 响应式原理](../vue/Vue响应式原理.md)

- JavaScript 严格模式下有哪些不同？

  <details>
  <summary>点击</summary>

  - 不允许不使用 var 关键字去创建全局变量，抛出 ReferenceError
  - 不允许对变量使用 delete 操作符，抛 ReferenceError
  - 不可对对象的只读属性赋值，不可对对象的不可配置属性使用 delete 操作符，不可为不可拓展的对象添加属性，均抛 TypeError
  - 对象属性名必须唯一
  - 函数中不可有重名参数
  - 在函数内部对修改参数不会反映到 arguments 中
  - 淘汰 arguments.callee 和 arguments.caller
  - 不可在 if 内部声明函数
  - 抛弃 with 语句

  </details>

- 说出下列代码的输出顺序？

  <details>
  <summary>点击</summary>

  ```html
  <div id="app">
    <span id="name" ref="name">{{ name }}</span>
    <button @click="change">change name</button>
    <div id="content"></div>
  </div>
  <script>
    new Vue({
      el: '#app',
      data() {
        return {
          name: 'SHERlocked93',
        };
      },
      methods: {
        change() {
          const $name = this.$refs.name;
          this.$nextTick(() => console.log('setter前：' + $name.innerHTML));
          this.name = ' name改喽 ';
          console.log('同步方式：' + this.$refs.name.innerHTML);
          setTimeout(() =>
            this.console('setTimeout方式：' + this.$refs.name.innerHTML)
          );
          this.$nextTick(() => console.log('setter后：' + $name.innerHTML));
          this.$nextTick().then(() =>
            console.log('Promise方式：' + $name.innerHTML)
          );
        },
      },
    });
  </script>
  ```

  这里涉及的知识是 vue.\$nextTick()原理，详情可查看[《全面解析 Vue.nextTick 实现原理》](https://mp.weixin.qq.com/s/mCcW4OYj3p3471ghMBylBw)

  ```
  同步方式：SHERlocked93
  setter前：SHERlocked93
  setter后：name改喽
  Promise方式：name改喽
  setTimeout方式：name改喽
  ```

  </details>

* 实现一个 LazyMan，可以按照以下方式调用

  > LazyMan(“Hank”) 输出: Hi! This is Hank!
  >
  > LazyMan(“Hank”).sleep(10).eat(“dinner”) 输出 Hi! This is Hank! // 等待 10 秒.. Wake up after 10 Eat dinner~
  >
  > LazyMan(“Hank”).eat(“dinner”).eat(“supper”) 输出 Hi This is Hank! Eat dinner~ Eat supper~

  <details>
  <summary>点击</summary>

  ```js
  class LazyMan {
    constructor(name) {
      this.name = name;
      this.asyncFun = Promise.resolve();
      console.log(`--------- 我就是 ${this.name}! ---------`);
    }
    sleep(delay) {
      this.asyncFun = this.asyncFun.then(() => {
        return new Promise(resolve => {
          setTimeout(() => {
            console.log(`--------- 我睡了 ${delay / 1000}s 然后 ----------`);
            resolve();
          }, delay);
        });
      });
      return this; //提供 ”链式调用“
    }
    eat(food) {
      this.asyncFun = this.asyncFun.then(() => {
        console.log(`--------- 吃 ${food}~ ---------`);
        return Promise.resolve();
      });
      return this;
    }
  }

  new LazyMan('小皮咖')
    .sleep(4000)
    .eat('豆浆')
    .eat('油条')
    .sleep(2000)
    .eat('炒年糕');
  ```

  </details>

* vue.\$set 的作用是？

  向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性

* 手写一个 sleep 函数？

  <details>
  <summary>点击</summary>

  ```js
  // 时间戳版本
  function sleep(time) {
    let startTime = new Date().getTime();
    while (new Date().getTime() - startTime < time) {}
    console.log('sleep ' + time + 'ms');
  }
  // promise
  function sleep2(time) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        console.log('sleep ' + time + 'ms');
        resolve();
      }, time);
    });
  }

  // 测试
  const haha = async () => {
    console.log(11);
    sleep(2000);
    await sleep2(3000);
    console.log(222);
  };

  haha();
  ```

  </details>

* 在堆中怎么插入一个元素？
