### 18-数组中找出和为 M 的 N 个数(番外篇)

还是同样的问题：

```
从一个数组中找出 N 个数，其和为 M 的所有可能
```

数组中选取不固定数值 N ，我们可以尝试着使用标记的方式，我们把 1 表示成选取状态， 把 0 表示成未选取状态。

假设数组 `const arr=[1,2,3,4]` ，对应着每个元素都有标记 0 或者 1 。如果 N=4 ，也就是在这个数组中，需要选择 4 个元素，那么对应的标记就只有一种可能 1111 ，如果 N=3 ，那就有 4 种可能，分别是 1110 、 1101 、1011 以及 0111 (也就是 C4 取 3->4 ) 种可能。

标记中有几个 1 就是代表选取了几个数，然后再去遍历这些 1 所有可能存在的排列方式，最后做一个判断，这个判断就是：每一种排列方式，都代表着数组中不同位置的被选中的数的组合，所以这里就是将选中的这些数字，进行求和运算，然后判断求出的和是不是等于 M 。

### 如何将数组和标记关联

> 0101 明显就是二进制嘛

对于 arr 来说，有 4 个元素，对应的选择方式就是从 0000（ N = 0 ）到 1111( N = 4 )的所有可能。

而 1111 就是 15 的二进制，也就是说这所有的可能其实对应的就是 0 - 15 中所有数对应的二进制。

> 这里的问题最终变成了如何从数组长度 4 推导出 0 - 15

这里采用了位运算--左移运算， 1 << 4 的结果是 16 。
所以我们可以建立这样一个迭代：

```js
const arr = [1, 2, 3, 4];
let len = arr.length,
  bit = 1 << len;

// 这里忽略了 0 的情况(N = 0)，取值就是 1 - 15
for (let i = 1; i < bit; i++) {
  // ...
}
```

### 如何从 1110 标记中取出 1 的个数

最简单的方式：

```js
const n = num => num.toString(2).replace(/0/g, '').length;
```

这其实也是一道算法常考题，因为位运算是不需要编译的，肯定速度最快。

PS: 如果不理解位运算为何会提高性能的同学，可以自行搜索一下位运算。简单点说就是：位运算直接用二进制进行表示，省去了中间过程的各种复杂转换，提高了速度。

我们尝试使用 & 运算来解决这个问题

首先我们肯定知道 `1 & 1 = 1; 1 & 0 = 0` 这些结论的。所以我们从 `15 & 14 => 14` 可以推导出 `1111 & 1110 => 1110` ，为什么可以这样推导呢，因为 15 的二进制就是 1111 ，14 同理。

我们可以看到，通过上面的操作消掉了最后的 1。

所以我们可以建立一个迭代，通过统计消除的次数，就能确定最终有几个 1 了。代码如下：

```js
const n = num => {
  let count = 0;
  while (num) {
    num &= num - 1;
    count++;
  }
  return count;
};
```

### 计算和等于 M

现在我们已经可以把所有的选取可能转变为遍历一个数组，然后通过迭代数组中的每个数对应的二进制，有几个 1 来确定选取元素的个数。

那么，现在需要的最后一层判断就是选取的这些数字和必须等于 M

这里其实就是建立一个映射：

1110 到 [1, 2, 3, 4] 的映射，就代表选取了 2, 3, 4，然后判断 2 + 3 + 4 与 M 。

这里可以这样看：1110 中的左边第一个 1 对应着数组 [1, 2, 3, 4] 中的 1 。

现在有一个问题，该如何建立这个映射关系呢？

我们知道前者 1110 其实就是对应的外层遍历中的 i = 14 的情况。

再看看数组[1, 2, 3, 4] ，我们可以将元素及其位置分别映射为 1000 0100 0010 0001。

实现方式也是通过位运算--左位移来实现：

```
1 << inx ，inx 为数组的下标。
```

### 位掩码介绍

对 **位掩码** 不熟悉的童鞋会有点晕，这里简单科普下：

实质上，这里的 1 << j ，是指使用 1 的移位来生成其中仅设置第 j 位的位掩码。

比如：14 的二进制表示为 1110，其代表（从右往左）选取了第 2 , 3 , 4 位。

那么(下面故意写成上下对应的方式)：

```js
// demo1
1110 & 0001 = 0000;

// demo2
1110 & 0010 = 0010;
```

PS: 通过上面代码，我们可以看到上下对应的 0 和 1 在进行 & 运算以后，得出的结果和在 js 中进行相同条件下 & 运算的结果相同。

所以：

```js
1 << 0 // 1 -> 0001
1 << 1 // 2 -> 0010
1 << 2 // 4 -> 0100
1 << 3 // 8 -> 1000

// 说白了，就是把左边的值变成二进制形式，然后左移或者右移，超出补 0

// 所以， 1110 对应着 第一位没有选取，那么 1110 & 0001(设置为第一位的位掩码) = 0，如果 i & (1 << inx) !== 0 代表该位被选取了
for(let j = 0; j < arr.length; j++){
    if((i & (1 << j) !== 0) {
    // 代表这个数被选取了，我们做累加求和就行
    }
}
```

复制代码所以综上所述，最终代码实现如下：

```js
// 参数依次为目标数组、选取元素数目、目标和
const search = (arr, count, sum) => {
  // 计算某选择情况下有几个 `1`，也就是选择元素的个数
  const n = num => {
    let count = 0;
    while (num) {
      num &= num - 1;
      count++;
    }
    return count;
  };

  let len = arr.length,
    bit = 1 << len,
    res = [];

  // 遍历所有的选择情况
  for (let i = 1; i < bit; i++) {
    // 满足选择的元素个数 === count
    if (n(i) === count) {
      let s = 0,
        temp = [];

      // 每一种满足个数为 N 的选择情况下，继续判断是否满足 和为 M
      for (let j = 0; j < len; j++) {
        // 建立映射，找出选择位上的元素
        if ((i & (1 << j)) !== 0) {
          s += arr[j];
          temp.push(arr[j]);
        }
      }

      // 如果这种选择情况满足和为 M
      if (s === sum) {
        res.push(temp);
      }
    }
  }

  return res;
};
```

### 总结

这里位操作思路和代码都很棒。但是 bit 位移有溢出问题。当数组长度大于 30 的时候，位操作已经溢出不精准。因此仅供参考其思想，不能作为其标准答案。

原文地址: [从一个数组中找出 N 个数，其和为 M 的所有可能--最 nice 的解法](https://juejin.im/post/5c81d543f265da2deb6ad691)
