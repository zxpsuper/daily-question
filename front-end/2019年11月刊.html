<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>2019年11月刊 | 每日一题</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="关于前端的每日一题">
    
    <link rel="preload" href="/daily-question/assets/css/0.styles.8fdb393e.css" as="style"><link rel="preload" href="/daily-question/assets/js/app.5c35efce.js" as="script"><link rel="preload" href="/daily-question/assets/js/2.c25e788d.js" as="script"><link rel="preload" href="/daily-question/assets/js/16.f67f6da9.js" as="script"><link rel="prefetch" href="/daily-question/assets/js/10.9c3c9185.js"><link rel="prefetch" href="/daily-question/assets/js/11.98ea9c56.js"><link rel="prefetch" href="/daily-question/assets/js/12.032325fa.js"><link rel="prefetch" href="/daily-question/assets/js/13.c03a3f8d.js"><link rel="prefetch" href="/daily-question/assets/js/14.3afbb98b.js"><link rel="prefetch" href="/daily-question/assets/js/15.8e46d44a.js"><link rel="prefetch" href="/daily-question/assets/js/3.9175481d.js"><link rel="prefetch" href="/daily-question/assets/js/4.fdb024c1.js"><link rel="prefetch" href="/daily-question/assets/js/5.7aeca0e3.js"><link rel="prefetch" href="/daily-question/assets/js/6.96b692af.js"><link rel="prefetch" href="/daily-question/assets/js/7.a2376f4e.js"><link rel="prefetch" href="/daily-question/assets/js/8.0c2201e0.js"><link rel="prefetch" href="/daily-question/assets/js/9.d9b6ac30.js">
    <link rel="stylesheet" href="/daily-question/assets/css/0.styles.8fdb393e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/daily-question/" class="home-link router-link-active"><!----> <span class="site-name">每日一题</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/daily-question/front-end/2019年03月刊.html" class="nav-link">
  每日一题
</a></div><div class="nav-item"><a href="https://github.com/zxpsuper/daily-question" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/daily-question/front-end/2019年03月刊.html" class="nav-link">
  每日一题
</a></div><div class="nav-item"><a href="https://github.com/zxpsuper/daily-question" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/daily-question/front-end/2019年03月刊.html" class="sidebar-link">2019年03月刊</a></li><li><a href="/daily-question/front-end/2019年04月刊.html" class="sidebar-link">2019年04月刊</a></li><li><a href="/daily-question/front-end/2019年05月刊.html" class="sidebar-link">2019年05月刊</a></li><li><a href="/daily-question/front-end/2019年06月刊.html" class="sidebar-link">2019年06月刊</a></li><li><a href="/daily-question/front-end/2019年07月刊.html" class="sidebar-link">2019年07月刊</a></li><li><a href="/daily-question/front-end/2019年08月刊.html" class="sidebar-link">2019年08月刊</a></li><li><a href="/daily-question/front-end/2019年09月刊.html" class="sidebar-link">2019年09月刊</a></li><li><a href="/daily-question/front-end/2019年10月刊.html" class="sidebar-link">2019年10月刊</a></li><li><a href="/daily-question/front-end/2019年11月刊.html" class="active sidebar-link">2019年11月刊</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/daily-question/front-end/2019年11月刊.html#_2019-11-18-2019-11-26" class="sidebar-link">2019/11/18 - 2019/11/26 ⌚️</a></li><li class="sidebar-sub-header"><a href="/daily-question/front-end/2019年11月刊.html#_2019-11-11-2019-11-17" class="sidebar-link">2019/11/11 - 2019/11/17 ⌚️</a></li><li class="sidebar-sub-header"><a href="/daily-question/front-end/2019年11月刊.html#_2019-11-04-2019-11-10" class="sidebar-link">2019/11/04 - 2019/11/10 ⌚️</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_2019年11月刊"><a href="#_2019年11月刊" class="header-anchor">#</a> 2019年11月刊</h1> <h2 id="_2019-11-18-2019-11-26"><a href="#_2019-11-18-2019-11-26" class="header-anchor">#</a> <strong>2019/11/18 - 2019/11/26</strong> ⌚️</h2> <ul><li><p>fetch() 与 XMLHttpRequest 的区别</p> <details><summary>点击</summary> <ol><li><p>fetch() 使用 Promise，不使用回调函数，因此大大简化了写法，写起来更简洁。</p></li> <li><p>fetch() 采用模块化设计，API 分散在多个对象上（Response 对象、Request 对象、Headers 对象），更合理一些；相比之下，XMLHttpRequest 的 API 设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码。</p></li> <li><p>fetch() 通过数据流（Stream 对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用。XMLHTTPRequest 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来。</p></li></ol></details></li> <li><p>Hook 和 Mixin &amp; HOC 对比</p> <details><summary>点击</summary> <p>Mixin &amp; HOC 模式缺点：</p> <ol><li><p>渲染上下文中公开的属性的来源不清楚。 例如，当使用多个 mixin 读取组件的模板时，可能很难确定从哪个 mixin 注入了特定的属性。</p></li> <li><p>命名空间冲突。 Mixins 可能会在属性和方法名称上发生冲突，而 HOC 可能会在预期的 prop 名称上发生冲突。</p></li> <li><p>性能问题，HOC 和无渲染组件需要额外的有状态组件实例，这会降低性能。</p></li></ol> <p>Hook 优点：</p> <ol><li><p>暴露给模板的属性具有明确的来源，因为它们是从 Hook 函数返回的值。</p></li> <li><p>Hook 函数返回的值可以任意命名，因此不会发生名称空间冲突。</p></li> <li><p>没有创建仅用于逻辑重用的不必要的组件实例。</p></li></ol></details></li> <li><p>promise的优缺点?</p> <details><summary>点击</summary> <p>缺点：</p> <p>1、无法取消</p> <p>2、如果不设置回调函数，promise内部抛出的错误，不会反应到外部。</p> <p>3、当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p> <p>优点：</p> <p>1、解决回调地狱</p> <p>2、可以统一处理错误</p></details></li></ul> <h2 id="_2019-11-11-2019-11-17"><a href="#_2019-11-11-2019-11-17" class="header-anchor">#</a> <strong>2019/11/11 - 2019/11/17</strong> ⌚️</h2> <ul><li><p><a href="https://www.yuque.com/zhengxiaopeng/szlr4s/gt1vuc" target="_blank" rel="noopener noreferrer">Tree-shaking及副作用<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>如何实现 webpack loader？</p></li> <li><p>Webpack 如何实现热更新？</p> <details><summary>点击</summary> <p>Webpack 如何实现热更新的呢？</p> <p>首先是建立起浏览器端和服务器端之间的通信，浏览器会接收服务器端推送的消息，如果需要热更新，浏览器发起 http 请求去服务器端获取打包好的资源解析并局部刷新页面。</p> <p>详细解说可以查看这篇文章：<a href="https://mp.weixin.qq.com/s/-DZ5vMaiOhFsOb9RDx71wg" target="_blank" rel="noopener noreferrer">《把 webpack 热更新原理聊清楚》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></details></li> <li><p>如何判断单链表是否带环？</p> <details><summary>点击</summary> <ol><li>创建哈希表，时间复杂度O(n)，不过会占用较大的空间,不是最佳方法</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">judge</span><span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span>
    list <span class="token operator">=</span> list<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ol start="2"><li>添加标记法，时间复杂度O(n)，不需要额外的空间</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">judge</span><span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span>visited<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    list<span class="token punctuation">.</span>visited <span class="token operator">=</span> <span class="token boolean">true</span>
    list <span class="token operator">=</span> list<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ol start="3"><li>快慢指针法，设定快指针fast, 慢指针slow, 每次循环快指针fast移动两个位置, 慢指针移动一个位置。快指针fast和慢指针slow若存在相遇，说明链表中存在环</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">judge</span><span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> fast <span class="token operator">=</span> list<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
  <span class="token keyword">var</span> slow <span class="token operator">=</span> list<span class="token punctuation">.</span>next
  <span class="token keyword">while</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">===</span> slow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></details></li> <li><p>何为纯函数？</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。

该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变（mutation）。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p><code>useEffect</code> 和 <code>useLayoutEffect</code> 的区别？</p> <details><summary>点击</summary> <p>传给 useEffect 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因为绝大多数操作不应阻塞浏览器对屏幕的更新</p> <p>useLayoutEffect 会在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。
</p></details><p></p></li> <li><p>Hook 使用规则</p> <blockquote><p>只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。</p> <p>只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中）</p></blockquote></li></ul> <h2 id="_2019-11-04-2019-11-10"><a href="#_2019-11-04-2019-11-10" class="header-anchor">#</a> <strong>2019/11/04 - 2019/11/10</strong> ⌚️</h2> <ul><li><p><a href="https://www.yuque.com/zhengxiaopeng/szlr4s/wa35e4" target="_blank" rel="noopener noreferrer">从页面 A 打开一个新页面 B，B 页面关闭（包括意外崩溃），如何通知 A 页面？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>js 如何获取和设置 css 变量？</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 获取一个 Dom 节点上的 CSS 变量</span>
element<span class="token punctuation">.</span>style<span class="token punctuation">.</span><span class="token function">getPropertyValue</span><span class="token punctuation">(</span><span class="token string">&quot;--my-var&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取任意 Dom 节点上的 CSS 变量</span>
<span class="token function">getComputedStyle</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPropertyValue</span><span class="token punctuation">(</span><span class="token string">&quot;--my-var&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 修改一个 Dom 节点上的 CSS 变量</span>
element<span class="token punctuation">.</span>style<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">&quot;--my-var&quot;</span><span class="token punctuation">,</span> jsVar <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p>React.PureComponent 与 React.Component 的区别</p> <details><summary>点击</summary> <p>两者的区别在于 React.Component 并未实现 shouldComponentUpdate()，而 React.PureComponent 中以浅层对比 prop 和 state 的方式来实现了该函数。</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>注意

React.PureComponent 中的 shouldComponentUpdate() 仅作对象的浅层比较。如果对象中包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。仅在你的 props 和 state 较为简单时，才使用 React.PureComponent，或者在深层数据结构发生变化时调用 forceUpdate() 来确保组件被正确地更新。你也可以考虑使用 immutable 对象加速嵌套数据的比较。

此外，React.PureComponent 中的 shouldComponentUpdate() 将跳过所有子组件树的 prop 更新。因此，请确保所有子组件也都是“纯”的组件。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></details></li> <li><p>React.memo 的作用</p> <details><summary>点击</summary> <p>React.memo 为高阶组件。</p> <p>如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p></details></li> <li><p>React.StrictMode 的作用</p> <details><summary>点击</summary> <p>StrictMode 是一个用来突出显示应用程序中潜在问题的工具。与 Fragment 一样, StrictMode 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。</p> <p>严格模式检查仅在开发模式下运行；它们不会影响生产构建。</p> <p>StrictMode 目前有助于：</p> <ul><li>识别不安全的生命周期</li> <li>关于使用过时字符串 ref API 的警告</li> <li>关于使用废弃的 findDOMNode 方法的警告</li> <li>检测意外的副作用</li> <li>检测过时的 context API</li></ul></details></li> <li><p>受控组件 vs 非受控组件</p> <details><summary>点击</summary> <p>React 有两种不同的方式来处理表单输入。</p> <p>如果一个 input 表单元素的值是由 React 控制，就其称为受控组件。当用户将数据输入到受控组件时，会触发修改状态的事件处理器，这时由你的代码来决定此输入是否有效（如果有效就使用更新后的值重新渲染）。如果不重新渲染，则表单元素将保持不变。</p> <p>一个非受控组件，就像是运行在 React 体系之外的表单元素。当用户将数据输入到表单字段（例如 input，dropdown 等）时，React 不需要做任何事情就可以映射更新后的信息。然而，这也意味着，你无法强制给这个表单字段设置一个特定值。</p> <p>在大多数情况下，你应该使用受控组件</p></details></li> <li><p>react class 组件的缺点</p> <details><summary>点击</summary> <ul><li>需要绑定 this 的指向</li> <li>class 不能很好的压缩</li> <li>会使热重载出现不稳定的情况</li></ul></details></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/daily-question/front-end/2019年10月刊.html" class="prev">
        2019年10月刊
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/daily-question/assets/js/app.5c35efce.js" defer></script><script src="/daily-question/assets/js/2.c25e788d.js" defer></script><script src="/daily-question/assets/js/16.f67f6da9.js" defer></script>
  </body>
</html>
